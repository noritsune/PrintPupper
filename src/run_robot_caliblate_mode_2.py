import numpy as np
from enum import IntEnum, auto
import time
import threading
import queue
from Config import Configuration
from HardwareInterface import HardwareInterface
from State import State
from JoystickInterface import JoystickInterface

DEFAULTNEUTRAL_ANGLE_DEGREES = np.array(
[[  0.,  0.,  0.,  0.],
 [ 45., 45., 45., 45.],
 [-45.,-45.,-45.,-45.]]
)

class Btn(IntEnum):
    NEXT = auto()
    EXIT = auto()
    HIP_UP = auto()
    HIP_DOWN = auto()
    LEG_UP = auto()
    LEG_DOWN = auto()
    KNEE_UP = auto()
    KNEE_DOWN = auto()

class run_robot_caliblate_mode():
    def __init__(self, config, hardware_interface, joystick_interface):
        self.configif = config
        self.hardwareif = hardware_interface
        self.joystickif = joystick_interface
        self.state = State()

        self.blink_fast = True
        self.mode_btn_que = queue.Queue()
        self.subloop_exit = False
        self.subloop_thread = threading.Thread(target=self.pad_input_subloop)
        self.subloop_thread.start()

        # If this line enable, calibration values are reset as every calibration operate.
        #self.hardwareif.servo_params.neutral_angle_degrees = DEFAULTNEUTRAL_ANGLE_DEGREES

        self.target_neutraldegs = self.hardwareif.servo_params.neutral_angle_degrees
        self.tmp_neutraldegs = self.target_neutraldegs.copy()
        print('Before Calibrattion')
        print(self.tmp_neutraldegs)
        self.ndeg_ofsts = self.tmp_neutraldegs - DEFAULTNEUTRAL_ANGLE_DEGREES
        self.ndeg_ofsts *= -1

        self.all_servo_neutral_signal()

        while True:
            try:
                btn = self.mode_btn_que.get(timeout=0.1)
                if btn == Btn.NEXT:
                    break
            except queue.Empty:
                continue

        self.blink_fast = False
        mode_exit = False
        while True:
            for leg in range(4):
                mode_exit = self.caliblate_leg(leg)
                if mode_exit:
                    break
            if mode_exit:
                break

        self.ndeg_ofsts *= -1
        self.tmp_neutraldegs = self.ndeg_ofsts + DEFAULTNEUTRAL_ANGLE_DEGREES
        self.target_neutraldegs = self.tmp_neutraldegs.copy()
        print('After Calibrattion')
        print(self.target_neutraldegs)
        self.overwrite_ServoCalibration_file()

        self.subloop_exit = True
        self.subloop_thread.join(timeout=1)
        return


    def pad_input_subloop(self):
        self.joystickif.get_command(self.state)
        pre_msg = self.joystickif.get_last_msg()
        tick = 0
        tack = True
        self.hardwareif.set_led_green(0)
        self.hardwareif.set_led_blue(0)

        while not self.subloop_exit:
            command = self.joystickif.get_command(self.state)
            msg = self.joystickif.get_last_msg()

            if (not pre_msg["triangle"]) and (msg["triangle"]):
                self.mode_btn_que.put(Btn.HIP_UP)

            if (not pre_msg["square"]) and (msg["square"]):
                self.mode_btn_que.put(Btn.HIP_DOWN)

            if (pre_msg["dpady"] == 0) and (msg["dpady"] == 1):
                self.mode_btn_que.put(Btn.LEG_UP)

            if (pre_msg["dpady"] == 0) and (msg["dpady"] == -1):
                self.mode_btn_que.put(Btn.LEG_DOWN)

            if (pre_msg["dpadx"] == 0) and (msg["dpadx"] == 1):
                self.mode_btn_que.put(Btn.KNEE_UP)

            if (pre_msg["dpadx"] == 0) and (msg["dpadx"] == -1):
                self.mode_btn_que.put(Btn.KNEE_DOWN)

            if (not pre_msg["circle"]) and (msg["circle"]):
                self.mode_btn_que.put(Btn.NEXT)

            if command.caliblate_mode_event:
                command.caliblate_mode_event = False
                self.mode_btn_que.put(Btn.EXIT)

            if (self.blink_fast and (tick % 25) == 0) or ((tick % 100) == 0):
                if tack:
                    self.hardwareif.set_led_green(1)
                    self.hardwareif.set_led_blue(0)
                else:
                    self.hardwareif.set_led_green(0)
                    self.hardwareif.set_led_blue(1)
                tack = not tack

            tick += 1
            pre_msg = msg
            time.sleep(0.005)

        self.hardwareif.set_led_green(0)
        self.hardwareif.set_led_blue(0)
        return


    def set_actuator(self, deg, axis, leg):
        rad = deg * np.pi / 180.0
        self.hardwareif.set_actuator_position_noncab(rad, axis, leg)
        return


    def overwrite_ServoCalibration_file(self):
        preamble1 = "# WARNING : This file is machine generated by run_robot_caliblate_mode.py."
        preamble2 = "# Edit at your own risk."
        preamble3 = "import numpy as np"
        formatted_str = [[x for x in row] for row in self.target_neutraldegs]

        # Overwrite ServoCalibration.py file with modified values
        with open("/home/pi/PrintPupper/src/ServoCalibration.py", "w") as f:
            print(preamble1, file = f)
            print(preamble2, file = f)
            print(preamble3, file = f)
            print("NEUTRAL_ANGLE_DEGREES = np.array(", file = f)
            print(formatted_str, file = f)
            print(")", file = f)


    def caliblate_leg(self, leg):
        leg_pos = {0: "Front-Right", 1: "Front-Left", 2: "Back-Right", 3: "Back-Left"}
        print("caliblate_leg", leg_pos[leg])

        hip_val = self.ndeg_ofsts[0, leg]
        leg_val = self.ndeg_ofsts[1, leg]
        knee_val = self.ndeg_ofsts[2, leg]
        print(f"Sv1 Hip={hip_val} / Sv2 Leg={leg_val} / Sv3 Knee={knee_val}")
        self.set_actuator(hip_val, 0, leg)
        self.set_actuator(leg_val, 1, leg)
        self.set_actuator(knee_val, 2, leg)

        self.set_actuator(hip_val + 5, 0, leg)
        time.sleep(0.25)
        self.set_actuator(hip_val,  0, leg)
        time.sleep(0.25)
        self.set_actuator(hip_val + 5, 0, leg)
        time.sleep(0.25)
        self.set_actuator(hip_val,  0, leg)

        mode_exit = False
        btn = 0
        while True:
            try:
                btn = self.mode_btn_que.get(timeout=0.1)
            except queue.Empty:
                continue

            if btn == Btn.HIP_UP:
                hip_val += 0.5

            if btn == Btn.HIP_DOWN:
                hip_val -= 0.5

            if btn == Btn.LEG_UP:
                leg_val += 0.5

            if btn == Btn.LEG_DOWN:
                leg_val -= 0.5

            if btn == Btn.KNEE_UP:
                knee_val += 0.5

            if btn == Btn.KNEE_DOWN:
                knee_val -= 0.5

            print(f"Sv1 Hip={hip_val} / Sv2 Leg={leg_val} / Sv3 Knee={knee_val}")
            self.set_actuator(hip_val, 0, leg)
            self.set_actuator(leg_val, 1, leg)
            self.set_actuator(knee_val, 2, leg)

            if btn == Btn.NEXT:
                print('Btn.NEXT')
                break

            if btn == Btn.EXIT:
                print('Btn.EXIT')
                mode_exit = True
                break

            btn = 0

        self.ndeg_ofsts[0, leg] = hip_val
        self.ndeg_ofsts[1, leg] = leg_val
        self.ndeg_ofsts[2, leg] = knee_val
        return mode_exit


    def all_servo_neutral_signal(self):
        degree = 0
        for leg in range(0,4):
            for axis in range(0,3):
                self.set_actuator(degree, axis, leg)
                time.sleep(0.5)


if __name__ == '__main__':
    config = Configuration()
    hardware_interface = HardwareInterface()
    joystick_interface = JoystickInterface(config)
    run_robot_caliblate_mode(config, hardware_interface, joystick_interface)

